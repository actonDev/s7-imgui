* DONE <2020-06-22 Mon> adding s7
* emacs related
  #+BEGIN_SRC emacs-lisp
(c-set-style "cc")
  #+END_SRC

  #+RESULTS:
* DONE <2020-06-22 Mon> eclipse index
  After adding a =.cproject= (copying from an existing one) the indexer worked
  #+BEGIN_SRC xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
    	
    <storageModule moduleId="org.eclipse.cdt.core.settings">
        		
        <cconfiguration id="org.eclipse.cdt.core.default.config.1574687895">
            			
            <storageModule buildSystemId="org.eclipse.cdt.core.defaultConfigDataProvider" id="org.eclipse.cdt.core.default.config.1574687895" moduleId="org.eclipse.cdt.core.settings" name="Configuration">
                				
                <externalSettings/>
                				
                <extensions/>
                			
            </storageModule>
            			
            <storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
            		
        </cconfiguration>
        	
    </storageModule>
    	
    <storageModule moduleId="org.eclipse.cdt.core.pathentry">
        		
        <pathentry kind="src" path=""/>
        		
        <pathentry kind="out" path="build"/>
        	
    </storageModule>
    	
    <storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
    	
    <storageModule moduleId="org.eclipse.cdt.internal.ui.text.commentOwnerProjectMappings"/>
    	
    <storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
    
</cproject>
    
  #+END_SRC
* TODO tcp socket / repl
  options for the networking
  - sdl_net
** nanomsg next generation (nng)
   (nahh.. couldn't use simple/dummy AF_INET socket)
   
   - https://nng.nanomsg.org/man/v1.3.0/nng_recv.3.html
   - https://github.com/nanomsg/nng/blob/master/demo/reqrep/reqrep.c
   
   huh! it reads everything into a buffer, don't have to deal with that myself

   #+BEGIN_SRC c
char *   buf = NULL;
size_t   sz;
uint64_t val;
if ((rv = nng_recv(sock, &buf, &sz, NNG_FLAG_ALLOC)) != 0) {
 fatal("nng_recv", rv);
}      
   #+END_SRC

   #+BEGIN_QUOTE
   NNG_FLAG_ALLOC

   If this flag is present, then a “zero-copy” mode is used. In this
   case the caller must set the value of data to the location of
   another pointer (of type void *), and the sizep pointer must be
   set to a location to receive the size of the message body. The
   function will then allocate a message buffer (as if by
   nng_alloc()), fill it with the message body, and store it at the
   address referenced by data, and update the size referenced by
   sizep. The caller is responsible for disposing of the received
   buffer either by the nng_free() function or passing the message
   (also with the NNG_FLAG_ALLOC flag) in a call to nng_send().

   #+END_QUOTE
   - https://nng.nanomsg.org/
* s7 repl.scm
  357aaa1 commit broke the =libc_s7.c= generation
  (last working commit 7fb147f)

  but how does all this work?
  
  
  #+BEGIN_EXAMPLE scheme
  ;; cload.scm
  (define *cload-c-compiler* (if (provided? 'gcc) "gcc" (if (provided? 'clang) "clang" "cc")))
  #+END_EXAMPLE
* s7 remote socket repl
  example dumb repl
  #+BEGIN_SRC c
// s7.c
static void dumb_repl(s7_scheme *sc)
{
  while (true)
    {
      char buffer[512];
      fprintf(stdout, "\n> ");
      if (!fgets(buffer, 512, stdin)) break;  /* error or ctrl-D */
      if (((buffer[0] != '\n') || (strlen(buffer) > 1)))
	{
	  char response[1024];
	  snprintf(response, 1024, "(write %s)", buffer);
	  s7_eval_c_string(sc, response);
	}
    }
  fprintf(stdout, "\n");
  if (ferror(stdin))
    fprintf(stderr, "read error on stdin\n");
}  
  #+END_SRC
* returning char*, string etc, formatting strings
  - formatting
    #+BEGIN_SRC cpp
#include <sstream>
#include <iostream>


std::ostringstream stream;
stream << "Foo" << "bar" << std::endl;
std::string str = stream.str();
    #+END_SRC

  - returning strings
    #+BEGIN_SRC cpp
// returning char*

char* returnChar(){
  char* str = "blahblah";
  return str;
}
// BAD! I return a dangling pointer

char* returnC_str(){
  std::string myString = "nice";
  return myString.c_str();
}

// BAD! again, dangling pointer

char* returnHeapChar(){
  int lenght = 10;
  char * new_string = new char[length + 1]; // +1 for the terminating the string with 0
  std::string someString = "nice";
  std::strcpy(new:string, someString.c_str());
}

// OK! but I have to run delete myself

std::string returnStr(){
  // all good, go wild
}
    #+END_SRC
* c++ callbacks?
  to use for the tcp server

  Usage:
  #+BEGIN_SRC cpp
server.listen(1234, [](const char*) {
		      // doing something with data?
		    } )
  #+END_SRC

  https://stackoverflow.com/questions/20353210/usage-and-syntax-of-stdfunction
* <2020-06-24 Wed> app & repl?
  #+BEGIN_SRC sh :session *s7-imgui*
ninja -C build
./build/s7-imgui
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :results silent
(run-scheme "netcat localhost 1234")
  #+END_SRC

  #+BEGIN_SRC sh :session *scheme*
netcat localhost 1234
  #+END_SRC
* TODO repl problems
  #+BEGIN_SRC scheme
(display ;;as
 "hi" ;; 2nd line
 )

1
  #+END_SRC

** use read?
   #+BEGIN_SRC c
s7_pointer s7_read(s7_scheme *sc, s7_pointer port)
{
  if (is_input_port(port))
    {
      s7_pointer old_let;
      declare_jump_info();

      old_let = sc->curlet;
      sc->curlet = sc->nil;
      push_input_port(sc, port);

      store_jump_info(sc);
      set_jump_info(sc, READ_SET_JUMP);
      if (jump_loc != NO_JUMP)
	{
	  if (jump_loc != ERROR_JUMP)
	    eval(sc, sc->cur_op);
	}
      else
	{
	  push_stack_no_let_no_code(sc, OP_BARRIER, port);
	  push_stack_direct(sc, OP_EVAL_DONE);

	  eval(sc, OP_READ_INTERNAL);

	  if (sc->tok == TOKEN_EOF)
	    sc->value = eof_object;

	  if ((sc->cur_op == OP_EVAL_DONE) &&
	      (stack_op(sc->stack, s7_stack_top(sc) - 1) == OP_BARRIER))
	    pop_stack(sc);
	}
      pop_input_port(sc);
      sc->curlet = old_let;

      restore_jump_info(sc);
      return(sc->value);
    }
  return(simple_wrong_type_argument_with_type(sc, sc->read_symbol, port, an_input_port_string));
}   
   #+END_SRC
** Solution ?..
   - upon socket data, append to a string stream
   - try to "read" the  current stream string
     - if it succeeds, perfect, just eval the string & emptry the stream
     - if not, just wait until the next chunk of data. store the reader error

   upon new data, if there is pending error, but plenty of time
   (define ?) has passed, ignore the previous error and start reading
   from scratch. probably also send something to the connected client?
* TODO drawing from s7 draw function
  - mimic the processing nomenclature
    - =(define (setup) .. )=
    - =(define (draw) .. )=
  - ffi for the imgui functionality
    - bind them to s7
* TODO adding gtest
  #+BEGIN_SRC sh
meson wrap install gtest
  #+END_SRC
* buttons to compile run etc
  #+BEGIN_SRC emacs-lisp :results silent
(button-lock-mode 1)
(defun button/compile ()
  "Shout when clicked"
  (interactive)
  (message "compiling")
  (comint-send-string "*s7-imgui*" "ninja -C build\r")
  )

(defun button/run ()
  "Shout when clicked"
  (interactive)
  (message "running")
  (comint-send-string "*s7-imgui*" "./build/s7-imgui\r")
  )

(defun button/stop ()
  "Shout when clicked"
  (interactive)
  (message "stop")
  (interrupt-process "*s7-imgui*" comint-ptyp)
  )

(defun button/test ()
  "Shout when clicked"
  (interactive)
  (message "stop")
  (comint-send-string "*s7-imgui*" "./build/test/gtest-all\r")
  )

(button-lock-set-button (regexp-quote ">compile")
			'button/compile
			:face 'link )

(button-lock-set-button (regexp-quote ">run")
			'button/run
			:face 'link )

(button-lock-set-button (regexp-quote ">stop")
			'button/stop
			:face 'link )

(button-lock-set-button (regexp-quote ">test")
			'button/test
			:face 'link )
  #+END_SRC

  - >compile
  - >run
  - >stop
  - >test
* writing an inc! function
  #+BEGIN_SRC scheme
(define (inc! x)
  (format #t "increasing x: ~A ~A" x (symbol->value x))
  ((outlet (curlet)) x)

  ;; (set! ((outlet (curlet)) x) 2)
;;  (set! x (+ 1 x))
  ;; (format #t "x is now ~A" x)
)

(define x 0)
(inc! x)
(inc! 'x)
(symbol? 'x)
(symbol->value 'x)
(inc! x)
x ;; x is still 0

  #+END_SRC

  check
  #+BEGIN_EXAMPLE scheme
> (set! (lt 'a) 12)
  #+END_EXAMPLE
  in the documentation
* ielm repl window.. it always asks for window
  - exec-in-script
    is true for shell, it doesn't ask anything
    #+BEGIN_EXAMPLE emacs-lisp
(defun eir-repl-start (repl-buffer-regexp fun-repl-start &optional exec-in-script)
    #+END_EXAMPLE

    in =eir-eval-in-ielm=
    add a last argument =t= to the =eir-eval-in-repl-lisp= call

* r7rs.scm
** TODO windows? is it working?
   in linux there is plenty of magic
   - generates a c file
   - compiles it
   - dynamically loads it

** box
   #+BEGIN_SRC scheme
  (let ((e (box 1)))
    (test (box? e) #t)
    (test (unbox e) 1)
    (test (e 'value) 1)
    (set-box! e 2)
    (test (unbox e) 2)
    (test (string=? (object->string e) "(inlet 'type box-type 'value 2)") #t))

   #+END_SRC
* DONE <2020-06-28 Sun> building on windows
  - https://github.com/actonDev/SDL/commit/2da3b23c429c923cc38763d47626aa473f8013cf
    #+BEGIN_SRC meson
# wrong
sdl2 = library('sdl2',
	       link_args: core_ldflags,
	       # ...
	       )
# correct
sdl2_dep = declare_dependency(link_with : sdl2,
			      include_directories : core_inc,
			      link_args : core_ldflags)


# link arguments are in the dependency, not in the library! ugh
    #+END_SRC

  - https://github.com/actonDev/SDL/commit/3e11ce100ef74d11ef57f7d1ee837d67c7e2ab2c
    added the following defines on windows
    - SDL_VIDEO_OPENGL
    - SDL_VIDEO_OPENGL_WGL
** DONE cannot get window with opengl
   fixed in https://github.com/actonDev/SDL/commit/3e11ce100ef74d11ef57f7d1ee837d67c7e2ab2c
   in CMakeLists
   #+BEGIN_EXAMPLE
  if(SDL_VIDEO)
    if(VIDEO_OPENGL)
      set(SDL_VIDEO_OPENGL 1)
      set(SDL_VIDEO_OPENGL_WGL 1)
      set(SDL_VIDEO_RENDER_OGL 1)
      set(HAVE_VIDEO_OPENGL TRUE)
    endif()
  endif()
   #+END_EXAMPLE

   see also subprojects/sdl2/premake/VisualC/VS2008/SDL_config_premake.h
   #+BEGIN_EXAMPLE

#define SDL_VIDEO_DRIVER_WINDOWS 1
#define SDL_VIDEO_RENDER_OGL 1

   #endif
#ifndef SDL_VIDEO_RENDER_OGL
#define SDL_VIDEO_RENDER_OGL 1
#endif
#ifndef SDL_VIDEO_OPENGL
#define SDL_VIDEO_OPENGL 1
#endif
#ifndef SDL_VIDEO_OPENGL_WGL
#define SDL_VIDEO_OPENGL_WGL 1
#endif
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
   #mesondefine SDL_VIDEO_RENDER_D3D11 // it's on in premake
   #mesondefine SDL_VIDEO_RENDER_OGL // on premake
   #+END_EXAMPLE
** library: shared vs static
   #+BEGIN_QUOTE
  LINK : fatal error LNK1181: cannot open input file '..\subprojects\imgui-1.76\imgui.lib'
   #+END_QUOTE
   
   Solved by adding this in the project

   #+BEGIN_SRC meson
project('s7-imgui', 'cpp', 'c',
	default_options: [
	  'default_library=static', # this fixed it
	]
       )   
   #+END_SRC

   the =default_library=static= did the trick
* main function & windows
  Windows wants a WinMain function
  #+BEGIN_SRC c
// https://stackoverflow.com/a/58819006/8720686
#ifdef _WIN32
int APIENTRY WinMain(HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR lpCmdLine, int nCmdShow)
{
   return main(__argc, __argv);
}
#endif  
  #+END_SRC

  But, instead of that, if we link against the =sdl2_main= library, this is taken care of
* TODO opengl screenshot
  https://stackoverflow.com/questions/5862097/sdl-opengl-screenshot-is-black#5867170
* DONE <2020-07-01 Wed> windows: cannot build
  #+BEGIN_QUOTE
[3/16] Linking target examples/example_imgui.exe
FAILED: examples/example_imgui.exe 
c++ @examples/example_imgui.exe.rsp
c++.exe: error: winmm.lib: No such file or directory
c++.exe: error: version.lib: No such file or directory
c++.exe: error: imm32.lib: No such file or directory
c++.exe: error: opengl32.lib: No such file or directory
c++.exe: error: iphlpapi.lib: No such file or directory  
  #+END_QUOTE

  aaah, aha! it was using gcc. not msvc
  - wipe
  - setup build --backend vs

** checking windows compiler
   added a check in meson.build
   #+BEGIN_SRC sh
meson setup build-mingw
ninja -C build-mingw
   #+END_SRC
* TODO <2020-07-01 Wed> todo list: more bindings, mutex
** TODO bindings
   wrote some ffi utils, creating c-objects and sharing between c<->scheme

   TODO
   - slider
   - layout (same line 
** TODO layout
   check out the layout. how is it?
   #+BEGIN_SRC c
ImGui::SameLine();
   #+END_SRC
** DONE scheme macros for begin
     something like
     #+BEGIN_SRC scheme
(defmacro* imgui/m-window (:title title
				  :open open
				  ) . body
  `(begin
     (imgui/begin title open?)
     ,body
     (imgui/end)
     )
  )
     #+END_SRC

     ok, actual solution
     don't know if I can use define-macro* and pass the rest . body
     #+BEGIN_SRC scheme
(define-macro (imgui/m-begin args . body)
  `(begin
     (imgui/begin ,@args)
     ,@body
     (imgui/end)))
     #+END_SRC
** TODO mutex
   I can crash the application when sending quickly from the repl the =(draw)= definition. expected :)
   - use a mutex around the main loop
** TODO s7 ffi: free functions
   delete void* isn't very smart.. fix this :)
   but.. why wasn't the compiler complaining??
** TODO gc in float_arr not called
