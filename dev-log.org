* DONE <2020-06-22 Mon> adding s7
* emacs related
  #+BEGIN_SRC emacs-lisp
(c-set-style "cc")
  #+END_SRC

  #+RESULTS:
* DONE <2020-06-22 Mon> eclipse index
  After adding a =.cproject= (copying from an existing one) the indexer worked
  #+BEGIN_SRC xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
    	
    <storageModule moduleId="org.eclipse.cdt.core.settings">
        		
        <cconfiguration id="org.eclipse.cdt.core.default.config.1574687895">
            			
            <storageModule buildSystemId="org.eclipse.cdt.core.defaultConfigDataProvider" id="org.eclipse.cdt.core.default.config.1574687895" moduleId="org.eclipse.cdt.core.settings" name="Configuration">
                				
                <externalSettings/>
                				
                <extensions/>
                			
            </storageModule>
            			
            <storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
            		
        </cconfiguration>
        	
    </storageModule>
    	
    <storageModule moduleId="org.eclipse.cdt.core.pathentry">
        		
        <pathentry kind="src" path=""/>
        		
        <pathentry kind="out" path="build"/>
        	
    </storageModule>
    	
    <storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
    	
    <storageModule moduleId="org.eclipse.cdt.internal.ui.text.commentOwnerProjectMappings"/>
    	
    <storageModule moduleId="org.eclipse.cdt.make.core.buildtargets"/>
    
</cproject>
    
  #+END_SRC
* TODO tcp socket / repl
  options for the networking
  - sdl_net
** nanomsg next generation (nng)
   (nahh.. couldn't use simple/dummy AF_INET socket)
   
   - https://nng.nanomsg.org/man/v1.3.0/nng_recv.3.html
   - https://github.com/nanomsg/nng/blob/master/demo/reqrep/reqrep.c
   
   huh! it reads everything into a buffer, don't have to deal with that myself

   #+BEGIN_SRC c
char *   buf = NULL;
size_t   sz;
uint64_t val;
if ((rv = nng_recv(sock, &buf, &sz, NNG_FLAG_ALLOC)) != 0) {
 fatal("nng_recv", rv);
}      
   #+END_SRC

   #+BEGIN_QUOTE
   NNG_FLAG_ALLOC

   If this flag is present, then a “zero-copy” mode is used. In this
   case the caller must set the value of data to the location of
   another pointer (of type void *), and the sizep pointer must be
   set to a location to receive the size of the message body. The
   function will then allocate a message buffer (as if by
   nng_alloc()), fill it with the message body, and store it at the
   address referenced by data, and update the size referenced by
   sizep. The caller is responsible for disposing of the received
   buffer either by the nng_free() function or passing the message
   (also with the NNG_FLAG_ALLOC flag) in a call to nng_send().

   #+END_QUOTE
   - https://nng.nanomsg.org/
* s7 repl.scm
  357aaa1 commit broke the =libc_s7.c= generation
  (last working commit 7fb147f)

  but how does all this work?
  
  
  #+BEGIN_EXAMPLE scheme
  ;; cload.scm
  (define *cload-c-compiler* (if (provided? 'gcc) "gcc" (if (provided? 'clang) "clang" "cc")))
  #+END_EXAMPLE
* s7 remote socket repl
  example dumb repl
  #+BEGIN_SRC c
// s7.c
static void dumb_repl(s7_scheme *sc)
{
  while (true)
    {
      char buffer[512];
      fprintf(stdout, "\n> ");
      if (!fgets(buffer, 512, stdin)) break;  /* error or ctrl-D */
      if (((buffer[0] != '\n') || (strlen(buffer) > 1)))
	{
	  char response[1024];
	  snprintf(response, 1024, "(write %s)", buffer);
	  s7_eval_c_string(sc, response);
	}
    }
  fprintf(stdout, "\n");
  if (ferror(stdin))
    fprintf(stderr, "read error on stdin\n");
}  
  #+END_SRC
* returning char*, string etc, formatting strings
  - formatting
    #+BEGIN_SRC cpp
#include <sstream>
#include <iostream>


std::ostringstream stream;
stream << "Foo" << "bar" << std::endl;
std::string str = stream.str();
    #+END_SRC

  - returning strings
    #+BEGIN_SRC cpp
// returning char*

char* returnChar(){
  char* str = "blahblah";
  return str;
}
// BAD! I return a dangling pointer

char* returnC_str(){
  std::string myString = "nice";
  return myString.c_str();
}

// BAD! again, dangling pointer

char* returnHeapChar(){
  int lenght = 10;
  char * new_string = new char[length + 1]; // +1 for the terminating the string with 0
  std::string someString = "nice";
  std::strcpy(new:string, someString.c_str());
}

// OK! but I have to run delete myself

std::string returnStr(){
  // all good, go wild
}
    #+END_SRC
* c++ callbacks?
  to use for the tcp server

  Usage:
  #+BEGIN_SRC cpp
server.listen(1234, [](const char*) {
		      // doing something with data?
		    } )
  #+END_SRC

  https://stackoverflow.com/questions/20353210/usage-and-syntax-of-stdfunction
* <2020-06-24 Wed> app & repl?
  #+BEGIN_SRC sh :session *s7-imgui*
ninja -C build
./build/s7-imgui
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :results silent
(run-scheme "netcat localhost 1234")
  #+END_SRC

  #+BEGIN_SRC sh :session *scheme*
netcat localhost 1234
  #+END_SRC
* TODO repl problems
  #+BEGIN_SRC scheme
(display ;;as
 "hi" ;; 2nd line
 )

1
  #+END_SRC

** use read?
   #+BEGIN_SRC c
s7_pointer s7_read(s7_scheme *sc, s7_pointer port)
{
  if (is_input_port(port))
    {
      s7_pointer old_let;
      declare_jump_info();

      old_let = sc->curlet;
      sc->curlet = sc->nil;
      push_input_port(sc, port);

      store_jump_info(sc);
      set_jump_info(sc, READ_SET_JUMP);
      if (jump_loc != NO_JUMP)
	{
	  if (jump_loc != ERROR_JUMP)
	    eval(sc, sc->cur_op);
	}
      else
	{
	  push_stack_no_let_no_code(sc, OP_BARRIER, port);
	  push_stack_direct(sc, OP_EVAL_DONE);

	  eval(sc, OP_READ_INTERNAL);

	  if (sc->tok == TOKEN_EOF)
	    sc->value = eof_object;

	  if ((sc->cur_op == OP_EVAL_DONE) &&
	      (stack_op(sc->stack, s7_stack_top(sc) - 1) == OP_BARRIER))
	    pop_stack(sc);
	}
      pop_input_port(sc);
      sc->curlet = old_let;

      restore_jump_info(sc);
      return(sc->value);
    }
  return(simple_wrong_type_argument_with_type(sc, sc->read_symbol, port, an_input_port_string));
}   
   #+END_SRC
** Solution ?..
   - upon socket data, append to a string stream
   - try to "read" the  current stream string
     - if it succeeds, perfect, just eval the string & emptry the stream
     - if not, just wait until the next chunk of data. store the reader error

   upon new data, if there is pending error, but plenty of time
   (define ?) has passed, ignore the previous error and start reading
   from scratch. probably also send something to the connected client?
* TODO drawing from s7 draw function
  - mimic the processing nomenclature
    - =(define (setup) .. )=
    - =(define (draw) .. )=
  - ffi for the imgui functionality
    - bind them to s7
* TODO adding gtest
  #+BEGIN_SRC sh
meson wrap install gtest
  #+END_SRC
* buttons to compile run etc
  #+BEGIN_SRC emacs-lisp :results silent
(button-lock-mode 1)
(defun button/compile ()
  "Shout when clicked"
  (interactive)
  (message "compiling")
  (comint-send-string "*s7-imgui*" "ninja -C build\r")
  )

(defun button/run ()
  "Shout when clicked"
  (interactive)
  (message "running")
  (comint-send-string "*s7-imgui*" "./build/s7-imgui\r")
  )

(defun button/stop ()
  "Shout when clicked"
  (interactive)
  (message "stop")
  (interrupt-process "*s7-imgui*" comint-ptyp)
  )

(defun button/test ()
  "Shout when clicked"
  (interactive)
  (message "stop")
  (comint-send-string "*s7-imgui*" "./build/test/gtest-all\r")
  )

(button-lock-set-button (regexp-quote ">compile")
			'button/compile
			:face 'link )

(button-lock-set-button (regexp-quote ">run")
			'button/run
			:face 'link )

(button-lock-set-button (regexp-quote ">stop")
			'button/stop
			:face 'link )

(button-lock-set-button (regexp-quote ">test")
			'button/test
			:face 'link )
  #+END_SRC

  - >compile
  - >run
  - >stop
  - >test
* writing an inc! function
  #+BEGIN_SRC scheme
(define (inc! x)
  (format #t "increasing x: ~A" x)
  (set! x (+ 1 x))
  (format #t "x is now ~A" x))

(define x 0)
(inc! x)
(inc! x)
;; not what I expected..

  #+END_SRC

  check
  #+BEGIN_EXAMPLE scheme
> (set! (lt 'a) 12)
  #+END_EXAMPLE
  in the documentation
* ielm repl window.. it always asks for window
  - exec-in-script
    is true for shell, it doesn't ask anything
    #+BEGIN_EXAMPLE emacs-lisp
(defun eir-repl-start (repl-buffer-regexp fun-repl-start &optional exec-in-script)
    #+END_EXAMPLE

    in =eir-eval-in-ielm=
    add a last argument =t= to the =eir-eval-in-repl-lisp= call

