* Foreign types (or c types)
  This was created in order to save the duplicate work when describing new foreign types. See more at https://orgmode.org/org.html#Noweb-Reference-Syntax
  Example code needed for a heap allocated bool
** oh the manual work that needed to be done

   #+BEGIN_SRC cpp
s7_pointer bool_make(s7_scheme *sc, s7_pointer args) {
	bool *data = new bool;
	,*data = s7_boolean(sc, s7_car(args));
	int type = s7_integer(s7_eval_c_string(sc, "(*c-primitives* 'type-bool)"));
	s7_pointer obj = s7_make_c_object(sc, type, (void*) data);

	return obj;
}

s7_pointer bool_ref(s7_scheme *sc, s7_pointer args) {
	bool *data = (bool*) s7_c_object_value(s7_car(args));

	return s7_make_boolean(sc, *data);
}

s7_pointer bool_set(s7_scheme *sc, s7_pointer args) {
	// 2 args: (block-set! (ref) value)
	if (s7_list_length(sc, args) != 2)
		return (s7_wrong_number_of_args_error(sc,
				"bool-set! takes 2 arguments: ~S", args));

	bool *data = (bool*) s7_c_object_value(s7_car(args));

	bool new_value = s7_boolean(sc, s7_cadr(args));
	,*data = new_value;

	return (s7_cadr(args));
}

void bind_primitives(s7_scheme *sc) {

	// either passing s7_curlet or s7_nil works..
	// ..ugh still don't know what happens with environments
	s7_pointer env = s7_inlet(sc, s7_nil(sc));
	s7_gc_protect(sc, env);

	// --- bool ----
	s7_int bool_type = s7_make_c_type(sc, "<bool>");
	// maybe renaming to bool-type ??
	s7_define(sc, env, s7_make_symbol(sc, "type-bool"),
			s7_make_integer(sc, bool_type));
	s7_define(sc, env, s7_make_symbol(sc, "bool"),
			s7_make_function(sc, "bool", bool_make, 1, 0, false,
					"creates a heap allocated bool (c-object)"));
	s7_c_type_set_ref(sc, bool_type, bool_ref);
	s7_c_type_set_set(sc, bool_type, bool_set);
	s7_c_type_set_free(sc, bool_type, primitive_free);
	//	s7_c_type_set_gc_free(sc, int_type, primitive_free_gc);

	s7_define(sc, s7_curlet(sc), s7_make_symbol(sc, "*c-primitives*"),
		  s7_sublet(sc, s7_nil(sc), s7_let_to_list(sc, env)));
}
   #+END_SRC
* elisp requirements
  The necessary elisp to be able to actually tangle this file
  
  packages:
  - dash.el

  #+BEGIN_SRC emacs-lisp
(use-package dash
  :demand t
  :require t)
  #+END_SRC

  Custom functions:

  #+BEGIN_SRC emacs-lisp :results silent
(defun aod.org/src-block-content (name)
  "Given a name of src block (which has the #+NAME: attr set),
it returns its contents"
  (org-save-outline-visibility nil ;; use markers?  
    (save-excursion
      (goto-char (org-babel-find-named-block name))
      (let ((src (org-element-property :value (org-element-at-point))))
	src))))
  #+END_SRC

* Primitives (bool, int, float, double)
** primite-template (make,ref,set,free,bind)

   #+NAME: primitive-template
   #+BEGIN_SRC c

// ------------------------------ C_TYPE ------------------------------

s7_pointer make_C_TYPE(s7_scheme *sc, s7_pointer args) {
     C_TYPE* data = new C_TYPE;
     ,*data = (C_TYPE) S7_READ(sc, s7_car(args));
     int type = s7_integer(s7_eval_c_string(sc, "(*foreign* 'type-C_TYPE)"));
     s7_pointer obj = s7_make_c_object(sc, type, (void*) data);
     return obj;
}

s7_pointer ref_C_TYPE(s7_scheme *sc, s7_pointer args) {
	C_TYPE* data = (C_TYPE*) s7_c_object_value(s7_car(args));

	return S7_WRITE(sc, *data);
}

s7_pointer set_C_TYPE(s7_scheme *sc, s7_pointer args) {
	// 2 args: (block-set! (ref) value)
	if (s7_list_length(sc, args) != 2) {
		return (s7_wrong_number_of_args_error(sc,
				"set! for C_TYPE takes 2 arguments: ~S", args));
	}
	C_TYPE* data = (C_TYPE*) s7_c_object_value(s7_car(args));
	s7_pointer s7_new_value = s7_cadr(args);
	C_TYPE new_value = S7_READ(sc, s7_new_value);
	,*data = new_value;

	return (s7_new_value);
}

void bind_C_TYPE(s7_scheme* sc, s7_pointer env) {
     /* s7_pointer env = s7_inlet(sc, s7_nil(sc)); */
     /* s7_gc_protect(sc, env); */

     // --- bool ----
     s7_int type = s7_make_c_type(sc, "<C_TYPE>");
     s7_define(sc, env, s7_make_symbol(sc, "type-C_TYPE"),
	       s7_make_integer(sc, type));
     s7_define(sc, env, s7_make_symbol(sc, "new-C_TYPE"),
	       s7_make_function(sc, "C_TYPE", make_C_TYPE, 1, 0, false,
				"creates a heap allocated C_TYPE (c-object)"));
     s7_c_type_set_ref(sc, type, ref_C_TYPE);
     s7_c_type_set_set(sc, type, set_C_TYPE);
     s7_c_type_set_free(sc, type, primitive_free);
}

// ! ---------------------------- C_TYPE ------------------------------
   #+END_SRC
** Generating src
   You can just as well evaluate this, it will render the c code the the =bool= type.
   This is later called for all of our types

  #+NAME: render
  #+BEGIN_SRC emacs-lisp :var template="primitive-template" type="bool" s7_read="s7_boolean" s7_write="s7_make_boolean" :wrap SRC cpp
(let ((case-fold-search nil))
  (-as-> (aod.org/src-block-content template) x
	 (replace-regexp-in-string "C_TYPE" type x t)
	 (replace-regexp-in-string "S7_READ" s7_read x t)
	 (replace-regexp-in-string "S7_WRITE" s7_write x t)
	 ))
  #+END_SRC

** foreign_primitives.hpp
  #+BEGIN_SRC cpp :tangle "foreign_primitives.hpp" :main no
#include "s7.h"

namespace aod {
     namespace s7 {
	  namespace foreign {
	       void bind_primitives(s7_scheme *sc);
	  }
     }
}
  #+END_SRC
** foreign_primitives.cpp
  #+BEGIN_SRC cpp :tangle "foreign_primitives.cpp" :noweb yes :main no
/**
 ,* This file was auto-generated with org-babel tangle.
 ,* See foreign_types.org for more info
 ,* I would suggest to not edit this by hand.
 ,**/

#include "s7.h"

namespace aod {
     namespace s7 {
	  namespace foreign {
	  void primitive_free(void *data) {
	       delete data;
	  }
	       
	  <<render(template="primitive-template",type="bool",s7_read="s7_boolean",s7_write="s7_make_boolean")>>

	  <<render(template="primitive-template",type="int",s7_read="s7_number_to_integer",s7_write="s7_make_integer")>>

	  // note: s7_make_real gets a double argument, not float. hope it gets automatically casted
	  <<render(template="primitive-template",type="float",s7_read="s7_number_to_real",s7_write="s7_make_real")>>

	  void bind_primitives(s7_scheme *sc) {
	       // either passing s7_curlet or s7_nil works..
	       // ..ugh still don't know what happens with environments
	       s7_pointer env = s7_inlet(sc, s7_nil(sc));
	       s7_gc_protect(sc, env);

	       // the bindings
	       bind_bool(sc, env);
	       bind_int(sc, env);
	       bind_float(sc, env);

	       s7_define(sc, s7_curlet(sc), s7_make_symbol(sc, "*foreign*"),
			 s7_sublet(sc, s7_nil(sc), s7_let_to_list(sc, env)));
	  }
	  } // foreign
     } // s7
} // aod
  #+END_SRC
* COMMENT Arrays in struct.. (bool[], int[], float[], double[])
** primite-arr-template (make,ref,set,free,bind)
   #+NAME: struct-template
   #+BEGIN_SRC c
typedef struct {
	size_t size;
	C_TYPE* elements;
} C_TYPE_arr;
   #+END_SRC

   #+NAME: primitive-arr-struct-template
   #+BEGIN_SRC c

// ------------------------------ C_TYPE-arr ------------------------------

/**
defined in the header

typedef struct {
	size_t size;
	C_TYPE* elements;
} C_TYPE_arr;
 ,**/

void free_C_TYPE_arr(void *raw_data) {
      C_TYPE* data = (C_TYPE*) raw_data;
      C_TYPE *elements = data->elements;
      delete[] elements;
      delete data;
}

s7_pointer make_C_TYPE_arr(s7_scheme *sc, s7_pointer args) {
	int len = s7_list_length(sc, args);
	if (len == 0) {
		return (s7_wrong_number_of_args_error(sc,
				"C_TYPE_arr creating needs >0 arguments: ~S", args));
	}
	s7_pointer p = args;
	C_TYPE_arr* data = new C_TYPE_arr;
	data->size = len;
	data->elements = new C_TYPE[len];
	for (int i = 0; i < len; i++) {
		data->elements[i] = (C_TYPE) S7_READ(sc, s7_car(p));
		p = s7_cdr(p);
	}

	int type = s7_integer(s7_eval_c_string(sc, "(*foreign* 'type-C_TYPE-arr)"));

	s7_pointer obj = s7_make_c_object(sc, type, (void*) data);

	return obj;
}

s7_pointer ref_C_TYPE_arr(s7_scheme *sc, s7_pointer args) {
	C_TYPE_arr* data = (C_TYPE_arr*) s7_c_object_value(s7_car(args));
	int index = s7_integer(s7_cadr(args));
	if (index >= data->size) {
		return (s7_out_of_range_error(sc, "float-arr-ref", 2, s7_cadr(args),
				"should be less than float-arr length"));
	}

	return S7_WRITE(sc, data->elements[index]);
}

s7_pointer set_C_TYPE_arr(s7_scheme *sc, s7_pointer args) {
	// 3 args: (block-set! data index value)
	if (s7_list_length(sc, args) != 3)
		return (s7_wrong_number_of_args_error(sc,
				"float-set! takes 3 arguments: ~S", args));

	C_TYPE_arr* data = (C_TYPE_arr*) s7_c_object_value(s7_car(args));
	int index = s7_integer(s7_cadr(args));
	if (index >= data->size) {
		return (s7_out_of_range_error(sc, "C_TYPE-arr-set!", 2, s7_cadr(args),
				"Index should be less than C_TYPE-arr length"));
	}

	C_TYPE new_value = S7_READ(sc, s7_caddr(args));

	data->elements[index] = new_value;

	return (s7_cadr(args));
}

void bind_C_TYPE_arr(s7_scheme* sc, s7_pointer env) {
     /* s7_pointer env = s7_inlet(sc, s7_nil(sc)); */
     /* s7_gc_protect(sc, env); */

     // --- bool ----
     s7_int type = s7_make_c_type(sc, "<C_TYPE-arr>");
     s7_define(sc, env, s7_make_symbol(sc, "type-C_TYPE-arr"),
	       s7_make_integer(sc, type_C_TYPE));
     s7_define(sc, env, s7_make_symbol(sc, "new-C_TYPE-arr"),
	       s7_make_function(sc, "new-C_TYPE-arr", make_C_TYPE, 1, 0, false,
				"creates a heap allocated C_TYPE-arr (c-object)"));
     s7_c_type_set_ref(sc, type, ref_C_TYPE_arr);
     s7_c_type_set_set(sc, type, set_C_TYPE_arr);
     s7_c_type_set_free(sc, type, free_C_TYPE_arr);
}

// ! ---------------------------- C_TYPE-arr ------------------------------
   #+END_SRC
** Generating src
  We use the render src block defined above.

  Demo expansion (run C-c above it)
  #+CALL: render(template="primitive-arr-struct-template",type="bool",s7_read="s7_boolean",s7_write="s7_make_boolean")

** foreign_primitives_arr.hpp
  #+BEGIN_SRC cpp :tangle "foreign_primitives_arr.hpp" :noweb yes
#include "s7.h"

namespace aod {
     namespace s7 {
	  <<render(template="struct-template",type="bool")>>
	  <<render(template="struct-template",type="int")>>
	  <<render(template="struct-template",type="float")>>

	  void bind_primitives_arr(s7_scheme *sc);
     }
}
  #+END_SRC
** foreign_primitives_arr.cpp
  #+BEGIN_SRC cpp :tangle "foreign_primitives_arr.cpp" :noweb yes
/**
 ,* This file was auto-generated with org-babel tangle.
 ,* See foreign_types.org for more info
 ,* I would suggest to not edit this by hand.
 ,**/

#include "s7.h"
#include "foreign_primitives_arr.hpp"

namespace aod {
     namespace s7 {
	  <<render(template="primitive-arr-struct-template",type="bool",s7_read="s7_boolean",s7_write="s7_make_boolean")>>

	  <<render(template="primitive-arr-struct-template",type="int",s7_read="s7_number_to_integer",s7_write="s7_make_integer")>>

	  // note: s7_make_real gets a double argument, not float. hope it gets automatically casted
	  <<render(template="primitive-arr-struct-template",type="float",s7_read="s7_number_to_real",s7_write="s7_make_real")>>

	  void bind_primitives_arr(s7_scheme *sc) {
	       // either passing s7_curlet or s7_nil works..
	       // ..ugh still don't know what happens with environments
	       s7_pointer env = s7_inlet(sc, s7_nil(sc));
	       s7_gc_protect(sc, env);

	       // the bindings
	       bind_bool_arr(sc, env);
	       bind_int_arr(sc, env);
	       bind_float_arr(sc, env);
	  }

     } // s7
} // aod
  #+END_SRC

** demo
   #+CALL: render(template="primitive-arr-struct-template",type="bool",s7_read="s7_boolean",s7_write="s7_make_boolean")

   #+CALL: render(template="primitive-arr-struct-template",type="float",s7_read="s7_number_to_real",s7_write="s7_make_real")

* Arrays (bool[], int[], float[], double[])
** primite[] arr template (make,ref,set,free,bind)
   #+NAME: T-primitive[]
   #+BEGIN_SRC c

// ------------------------------ C_TYPE-arr ------------------------------

void free_C_TYPE_arr(void *raw_data) {
      C_TYPE* data = (C_TYPE*) raw_data;
      /* C_TYPE *elements = data->elements; */
      delete[] data;
}

int length_C_TYPE_arr(void *data) {
      C_TYPE* arr = (C_TYPE*) raw_data;
      /* C_TYPE *elements = data->elements; */
      int len = sizeof(arr)/sizeof(arr[0]);

      return len;
}

s7_pointer make_C_TYPE_arr(s7_scheme *sc, s7_pointer args) {
	int len = s7_integer(s7_cadr(args));
	if (len == 0) {
		return (s7_wrong_number_of_args_error(sc,
				"C_TYPE_arr creating needs 1 positive argument for its length: ~S", args));
	}
	s7_pointer p = args;
	C_TYPE* data = new C_TYPE[len];

	int type = s7_integer(s7_eval_c_string(sc, "(*foreign* 'type-C_TYPE[])"));
	s7_pointer obj = s7_make_c_object(sc, type, (void*) data);

	return obj;
}

s7_pointer ref_C_TYPE_arr(s7_scheme *sc, s7_pointer args) {
	C_TYPE* arr = (C_TYPE_arr*) s7_c_object_value(s7_car(args));
	int index = s7_integer(s7_cadr(args));
	// TODO calculate size?
	int length = length_C_TYPE_arr(void *arr);
	if (index >= length) {
		return (s7_out_of_range_error(sc, "C_TYPE-arr-ref", 2, s7_cadr(args),
				"should be less than C_TYPE-arr length"));
	}

	return S7_WRITE(sc, arr[index]);
}

s7_pointer set_C_TYPE_arr(s7_scheme *sc, s7_pointer args) {
	// 3 args: (block-set! data index value)
	if (s7_list_length(sc, args) != 3)
		return (s7_wrong_number_of_args_error(sc,
				"float-set! takes 3 arguments: ~S", args));

	C_TYPE* arr = (C_TYPE*) s7_c_object_value(s7_car(args));
	int index = s7_integer(s7_cadr(args));
	int length = length_C_TYPE_arr(void *arr);
	if (index >= length) {
		return (s7_out_of_range_error(sc, "set! on C_TYPE[]", 2, s7_cadr(args),
				"Index should be less than C_TYPE length"));
	}

	C_TYPE new_value = S7_READ(sc, s7_caddr(args));

	arr[index] = new_value;

	return (s7_cadr(args));
}

void bind_C_TYPE_arr(s7_scheme* sc, s7_pointer env) {
     /* s7_pointer env = s7_inlet(sc, s7_nil(sc)); */
     /* s7_gc_protect(sc, env); */

     // --- bool ----
     s7_int type = s7_make_c_type(sc, "<C_TYPE-arr>");
     s7_define(sc, env, s7_make_symbol(sc, "type-C_TYPE-arr"),
	       s7_make_integer(sc, type_C_TYPE));
     s7_define(sc, env, s7_make_symbol(sc, "new-C_TYPE[]"),
	       s7_make_function(sc, "new-C_TYPE[]", make_C_TYPE, 1, 0, false,
				"creates a heap allocated C_TYPE[] (c-object)"));
     s7_c_type_set_ref(sc, type, ref_C_TYPE_arr);
     s7_c_type_set_set(sc, type, set_C_TYPE_arr);
     s7_c_type_set_free(sc, type, free_C_TYPE_arr);
}

// ! ---------------------------- C_TYPE-arr ------------------------------
   #+END_SRC
** Generating src
  We use the render src block defined above.

  Demo expansion (run C-c above it)
  #+CALL: render(template="T-primitive[]",type="bool",s7_read="s7_boolean",s7_write="s7_make_boolean")

** foreign_primitives_arr.hpp

   #+NAME: T-length-header[]
   #+BEGIN_SRC c
int length_C_TYPE_arr(void *data);
   #+END_SRC


  #+BEGIN_SRC cpp :tangle "foreign_primitives_arr.hpp" :noweb yes :main no
#include "s7.h"

namespace aod {
     namespace s7 {
	  namespace foreign {
	       <<render(template="T-length-header[]",type="bool")>>
	       <<render(template="T-length-header[]",type="int")>>
	       <<render(template="T-length-header[]",type="float")>>
	       void bind_primitives_arr(s7_scheme *sc);
	  }
     }
}
  #+END_SRC
** foreign_primitives_arr.cpp
  #+BEGIN_SRC cpp :tangle "foreign_primitives_arr.cpp" :noweb yes :main no
/**
 ,* This file was auto-generated with org-babel tangle.
 ,* See foreign_types.org for more info
 ,* I would suggest to not edit this by hand.
 ,**/

#include "s7.h"
#include "foreign_primitives_arr.hpp"

namespace aod {
     namespace s7 {
	  namespace foreign {
	       <<render(template="T-primitive[]",type="bool",s7_read="s7_boolean",s7_write="s7_make_boolean")>>

	       <<render(template="T-primitive[]",type="int",s7_read="s7_number_to_integer",s7_write="s7_make_integer")>>

		 // note: s7_make_real gets a double argument, not float. hope it gets automatically casted
	       <<render(template="T-primitive[]",type="float",s7_read="s7_number_to_real",s7_write="s7_make_real")>>

	       void bind_primitives_arr(s7_scheme *sc) {
		    // either passing s7_curlet or s7_nil works..
		    // ..ugh still don't know what happens with environments
		    s7_pointer env = s7_inlet(sc, s7_nil(sc));
		    s7_gc_protect(sc, env);

		    // the bindings
		    bind_bool_arr(sc, env);
		    bind_int_arr(sc, env);
		    bind_float_arr(sc, env);
	       }
	  } // foreign
     } // s7
} // aod
  #+END_SRC

** demo
   #+CALL: render(template="T-primitive[]",type="bool",s7_read="s7_boolean",s7_write="s7_make_boolean")

   #+CALL: render(template="T-primitive[]",type="float",s7_read="s7_number_to_real",s7_write="s7_make_real")
* Further notes
  I guess that mapping c++ classes could be easily done with this method..
* COMMENT Local variables
# Local Variables:
# eval: (setq-local org-confirm-babel-evaluate nil)
# End:
